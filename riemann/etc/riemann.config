; -*- mode: clojure; -*-
; vim: filetype=clojure

(logging/init :file "riemann.log")
(instrumentation  {:enabled? false}) ; Get a nice clean log

(require '[clj-http.client :as client])
(require '[cheshire.core :as json])

(defn notify-url [path] (str "http://localhost:3000/" path))

(defn notify [event]
  (client/patch (notify-url (:notify_endpoint event)) {
                                   :body (json/generate-string {(:type event) {:status (:state event)}})
                                   :content-type :json
                                   :accept :json
                                   }))

(def api-key (get (System/getenv) "GRAPHITE_API_KEY"))
(if-not api-key (throw (Throwable. "GRAPHITE_API_KEY must be set.")))

(def forward-graphite (graphite {:host "carbon.hostedgraphite.com"
                                 :port 2003
                                 :path (fn [x] (str api-key "." (:description x)))}))

; Listen on the local interface over TCP (5555), UDP (5555), and websockets
; (5556)
(let [host "127.0.0.1"]
  (tcp-server :host host)
  (udp-server :host host)
  (ws-server  :host host))

; Expire old events from the index every 5 seconds.
(periodically-expire 5 {:keep-keys [:host :service :tags]})

; Keep events in the index for 5 minutes by default.
(let [index (default :ttl 300 (update-index (index)))]
  ; Inbound events will be passed to these streams:
  (streams
    index
    forward-graphite
    (with {:metric 1 :host nil :state "ok" :service "events/sec"} (rate 5 index))))

(streams
  (tagged "check"
          (by [:host :service :component :type]
                  (changed :state notify))))

(streams
  (tagged "performance"
          (fn [event] (println "Performance: " (:description event)))))
