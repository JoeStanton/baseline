; -*- mode: clojure; -*-
; vim: filetype=clojure

(logging/init :file "riemann.log")
(instrumentation  {:enabled? false}) ; Get a nice clean log
(use '[clojure.java.shell :only  [sh]])

(require '[clj-http.client :as client])
(require '[cheshire.core :as json])

(defn service-status-url [service] (str "http://localhost:3000/services/" service))

(defn service-status [id status]
  (client/patch (service-status-url id) {
                                        :body (json/generate-string {:service {:status status}})
                                        :content-type :json
                                        :accept :json
                                        }))

(defn event-to-status [event] (if (= event "ok") "ok" "error"))

(defn alert [team event] (println "Ops Team Alert - " event))

; Listen on the local interface over TCP (5555), UDP (5555), and websockets
; (5556)
(let [host "127.0.0.1"]
  (tcp-server :host host)
  (udp-server :host host)
  (ws-server  :host host))

; Expire old events from the index every 5 seconds.
(periodically-expire 5 {:keep-keys [:host :service :tags]})

; Keep events in the index for 5 minutes by default.
(let [index (default :ttl 300 (update-index (index)))]
  ; Inbound events will be passed to these streams:
  (streams
    ; Index all events immediately.
    index
    ; Calculate an overall rate of events.
    (with {:metric 1 :host nil :state "ok" :service "events/sec"}
      (rate 5 index))
    ; Log expired events.
    (expired
      (fn [event] (info "expired" event)))
    ))

(defn alert [event] (println (str "Alert: " (:service event) " is " (:state event))))

(defn unusual? [event] append)

(streams
  (tagged "connectivity"
          (changed-state (fn [event] (service-status 2 (event-to-status(:state event))) (alert event)))))

(streams
  (tagged "exception" alert))

(streams
  (tagged "performance"
          (fn [event] (println "Performance: " (:description event)))
          (unusual? (println "Alert: Unusual performance metric detected"))))
